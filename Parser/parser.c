#include "parser.h"
#include "../Lexer/lexer.h"


/*
 * A top down order precedence parser (Pratt parser).
 * Input: Token stream of the Python language generated by lexer.c/main.c.
 * Output: AST to be translate into lower-level IR by tree-walker
 */


Parser parser;

Rule table[] = {
    [TOKEN_INTEGER]        = {Prec_Integers,    nud_integer, NULL},
    [TOKEN_IDENTIFIER]     = {Prec_Identifiers, nud_integer, NULL},
    [TOKEN_ADD]            = {Prec_AddSub,      NULL,        led_binary},
    [TOKEN_EQUALS]         = {Prec_Equals,      NULL,        led_binary},
    [TOKEN_MULTIPLICATION] = {Prec_MultDiv,     NULL,        led_binary},
    [TOKEN_EOF]            = {Prec_EOF,         NULL,        NULL},
};

TreeNode *led_binary(TreeNode *tree, StackNode **stack){
    TreeNode *new_node = spawn_node(parser.current);
    new_node->left = tree;
    new_node->right = parse(table[parser.current.type].precedence, tree, stack);
    return new_node;
}


TreeNode *nud_integer(TreeNode *tree, StackNode **stack){
    TreeNode *tree_node = spawn_node(parser.previous);
    return tree_node;
}




TreeNode *spawn_node(Token t){
    TreeNode *return_node = malloc(sizeof(*return_node));
    return_node->left = NULL;
    return_node->right = NULL;
    return_node->contents = t;
    return return_node;
}


StackNode *spawn_stack_node(TreeNode *t){
    StackNode *return_node = malloc(sizeof(StackNode));
    return_node->contents = t;
    return_node->next = NULL;
    return return_node;
}


void push(StackNode **stack, TreeNode *t){
    StackNode *push_node = spawn_stack_node(t);
    push_node->next = *stack;
    *stack = push_node;
}


TreeNode *pop(StackNode **stack){
    StackNode *temp = *stack;
    TreeNode *return_t = temp->contents;
    *stack = (*stack)->next;
    free(temp);
    return return_t;
}


bool is_stack_empty(StackNode **stack){
    if (*stack == NULL) {
        return true;
    } else {
        return false;
    }
}


bool is_tree_node_empty(TreeNode *node){
    if ((node->left == NULL) && (node->right == NULL)) {
        return true;
    } else {
        return false;
    }
}


void traverse_binary_tree(TreeNode *tree){
    // T1
    StackNode *stack = NULL;
    TreeNode *p = tree;
    int depth = 0;
    for (;;) {
        if (is_tree_node_empty(p) == true) { // T2
            for (int i = 0; i < depth; i++) {
                printf("\t");
            }
            printf("%s\n", print_type(p->contents.type));
            // T4
            if (is_stack_empty(&stack) == true) {
                break;
            } else {
                p = pop(&stack);
                depth--;
                // T5
                for (int i = 0; i < depth; i++) {
                    printf("\t");
                }
                printf("%s\n", print_type(p->contents.type));
                p = p->right;
                depth++;
            }
        } else {
            // T3
            push(&stack, p);
            p = p->left;
            depth++;
        }
    }
}


TreeNode *parse(Precedence rbp, TreeNode *tree, StackNode **stack){
    Token t = get_next_token();
    parser.previous = t;
    SemanticCode c = table[t.type].nud;
    if (c == NULL) {
        //printf("error in parse()\n");
    }
    TreeNode *left = c(tree, stack);
    while (rbp <= table[t.type].precedence) {
        Token t = get_next_token();
        if (t.type == TOKEN_EOF) {
            break;
        }
        parser.current = t;
        c = table[t.type].led;
        left = c(left, stack);
    }
    return left;
}
